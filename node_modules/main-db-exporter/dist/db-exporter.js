"use strict";
const sqlite3 = require('sqlite3');
const fs = require('fs');
const path = require('path');
const CONVERSATION_QUERY = 'select * from Conversations where exists (select convo_id from Messages where Conversations.id = Messages.convo_id)';
const CONVERSATION_COUNT_QUERY = 'select count(*) as total from Conversations where exists (select convo_id from Messages where Conversations.id = Messages.convo_id)';
const MESSAGE_QUERY_PARAM = 'select id, type, chatname, from_dispname, body_xml, timestamp from Messages where convo_id = $convoId order by timestamp asc';
const ACCOUNT_QUERY = 'select skypename, fullname from accounts';
class DbExporter {
    constructor(dbFilePath) {
        this.db = null;
        this.conversationCount = -1;
        if (!dbFilePath) {
            throw new Error('dbFilePath must be provided');
        }
        if (!fs.existsSync(dbFilePath)) {
            throw new Error(`Database file not found: ${dbFilePath}`);
        }
        sqlite3.verbose();
        this.folderName = path.basename(path.dirname(dbFilePath));
        this.db = new sqlite3.Database(dbFilePath);
        this.extractAccount();
    }
    done() {
        return new Promise((resolve, reject) => {
            if (this.db) {
                this.db.close((err) => {
                    this.db = null;
                    if (err) {
                        resolve(false);
                    }
                    else {
                        resolve(true);
                    }
                });
            }
            else {
                resolve(true);
            }
        });
    }
    getAccountInfo() {
        return this.accountInfo;
    }
    getConversationCount() {
        return new Promise((resolve, reject) => {
            if (this.conversationCount > -1) {
                resolve(this.conversationCount);
            }
            else {
                this.runQuery(CONVERSATION_COUNT_QUERY, {}, (row) => {
                    this.conversationCount = row.total;
                    resolve(this.conversationCount);
                }, () => { });
            }
        });
    }
    eachConversation(convProcessor, runAtEnd) {
        if (!convProcessor) {
            throw new Error('convProcessor must be provided');
        }
        return this.runQuery(CONVERSATION_QUERY, {}, (row) => convProcessor(row), runAtEnd);
    }
    eachMessage(conversationId, msgProcessor, runAtEnd) {
        if (!msgProcessor) {
            throw new Error('msgProcessor must be provided');
        }
        return this.runQuery(MESSAGE_QUERY_PARAM, { $convoId: conversationId }, (row) => msgProcessor(row), runAtEnd);
    }
    extractAccount() {
        this.runQuery(ACCOUNT_QUERY, {}, (row) => {
            let skypeName = row.skypename || this.folderName;
            let fullName = row.fullname || this.folderName;
            this.accountInfo = { fullName: fullName, skypeName: skypeName };
        }, () => { });
    }
    runQuery(query, params, processor, runAtEnd) {
        if (!query) {
            throw new Error('query must not be null');
        }
        if (!processor) {
            throw new Error('formatter must not be null');
        }
        if (!this.db) {
            throw new Error('Database not initialized');
        }
        this.db.serialize(() => {
            this.db.each(query, params, (err, row) => {
                if (err) {
                    console.log('Error while executing statement: ' + err.message);
                }
                else {
                    processor(row);
                }
            }, (err) => {
                if (err) {
                    throw new Error('Error while executing statement: ' + err.message);
                }
                runAtEnd();
            });
        });
    }
}
exports.DbExporter = DbExporter;
