"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
const sqlite3 = require('sqlite3');
const fs = require('fs');
const path = require('path');
const CONVERSATION_COUNT_QUERY = 'select count(*) as total from Conversations where exists (select convo_id from Messages where Conversations.id = Messages.convo_id)';
const ACCOUNT_QUERY = 'select skypename, fullname from accounts';
class AccountExporter {
    constructor(dbFilePaths) {
        this.accountInfo = [];
        if (!dbFilePaths) {
            throw new Error('dbFilePath must be provided');
        }
        this.dbPaths = dbFilePaths;
    }
    getAccountDetails() {
        return __awaiter(this, void 0, void 0, function* () {
            this.accountInfo = [];
            for (let dbPath of this.dbPaths) {
                try {
                    let info = yield this.processDatabase(dbPath);
                    this.accountInfo.push(info);
                }
                catch (err) {
                    console.log(`Error fetching account info for ${dbPath}: ${err.message}`);
                }
            }
            return this.accountInfo.sort((a, b) => {
                return b.conversationCount - a.conversationCount;
            });
        });
    }
    processDatabase(dbPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!fs.existsSync(dbPath)) {
                throw new Error(`Path doesn't exist: ${dbPath}`);
            }
            let fallbackUsername = path.basename(path.dirname(dbPath)).replace('#3a', ':');
            let db = new sqlite3.Database(dbPath);
            try {
                let account = yield this.getUser(db, fallbackUsername);
                account.dbPath = dbPath;
                account.conversationCount = yield this.getConvCount(db);
                yield this.close(db);
                return account;
            }
            catch (err) {
                yield this.close(db);
                throw err;
            }
        });
    }
    getUser(db, fallbackName) {
        return new Promise((resolve, reject) => {
            let skypeName = fallbackName;
            let fullName = fallbackName;
            db.serialize(() => {
                db.each(ACCOUNT_QUERY, {}, (err, row) => {
                    if (err) {
                        console.log('Error while executing statement: ' + err.message);
                    }
                    else {
                        skypeName = row.skypename || fallbackName;
                        fullName = row.fullname || fallbackName;
                    }
                }, (err) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve({
                            skypeName,
                            fullName
                        });
                    }
                });
            });
        });
    }
    getConvCount(db) {
        return new Promise((resolve, reject) => {
            let count;
            db.serialize(() => {
                db.each(CONVERSATION_COUNT_QUERY, {}, (err, row) => {
                    if (err) {
                        console.log('Error while executing statement: ' + err.message);
                    }
                    else {
                        count = row.total || 0;
                    }
                }, (err) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve(count);
                    }
                });
            });
        });
    }
    close(db) {
        return new Promise((resolve, reject) => {
            db.close((err) => {
                db = null;
                if (err) {
                    resolve(false);
                }
                else {
                    resolve(true);
                }
            });
        });
    }
}
exports.AccountExporter = AccountExporter;
