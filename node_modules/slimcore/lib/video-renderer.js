/// <reference path="slimcore.d.ts" />
/// <reference path="video-renderer.d.ts" />
'use strict';
const events_1 = require("events");
const version_1 = require("./version");
const SET_VIDEO_PREFERENCE_DEBOUNCE_TIMEOUT = 1000;
const VERTEX_SHADER = `
    attribute vec4 position;
    attribute vec2 texCoord;

    varying vec2 v_texCoord;

    void main()
    {
        gl_Position = position;
        v_texCoord = texCoord;
    }
`;
const FRAGMENT_SHADER_COMMON = `
    precision mediump float;
    varying vec2 v_texCoord;

    vec4 yuv2rgb(float y, float u, float v)
    {
        y = (y - 0.0625) * 1.164;
        u = u - 0.5;
        v = v - 0.5;

        float r = y             + 2.018 * v;
        float g = y - 0.391 * u - 0.813 * v;
        float b = y + 1.596 * u            ;

        return vec4(r, g, b, 1.0);
    }
`;
let formats = {};
formats['BG24'] = {
    'mapping': (gl, frame) => {
        return [{
                'data': new Uint8Array(frame.data),
                'width': frame.info.width,
                'height': frame.info.height,
                'stride': frame.info.stride,
                'format': gl.RGB,
            }];
    },
    'shader': `
        uniform sampler2D tex0;

        void main()
        {
            gl_FragColor = vec4(texture2D(tex0, v_texCoord).bgr, 1.0);
        }
    `,
};
formats['BGRA'] = {
    'mapping': (gl, frame) => {
        return [{
                'data': new Uint8Array(frame.data),
                'width': frame.info.width,
                'height': frame.info.height,
                'stride': frame.info.stride,
                'format': gl.RGBA,
            }];
    },
    'shader': `
        uniform sampler2D tex0;

        void main()
        {
            gl_FragColor = texture2D(tex0, v_texCoord).bgra;
        }
    `,
};
formats['UYVY'] = {
    'mapping': (gl, frame) => {
        let width = frame.info.width;
        let height = frame.info.height;
        let stride = frame.info.stride;
        return [{
                'data': new Uint8Array(frame.data),
                'width': width,
                'height': height,
                'stride': stride,
                'format': gl.LUMINANCE_ALPHA,
            }, {
                'data': new Uint8Array(frame.data),
                'width': width / 2,
                'height': height,
                'stride': stride,
                'format': gl.RGBA,
            }];
    },
    'shader': `
        uniform sampler2D tex0;
        uniform sampler2D tex1;

        void main()
        {
            float y = texture2D(tex0, v_texCoord)[%alpha%];
            float u = texture2D(tex1, v_texCoord)[0];
            float v = texture2D(tex1, v_texCoord)[2];

            gl_FragColor = yuv2rgb(y, u, v);
        }
    `,
};
formats['YUY2'] = {
    'mapping': formats['UYVY'].mapping,
    'shader': `
        uniform sampler2D tex0;
        uniform sampler2D tex1;

        void main()
        {
            float y = texture2D(tex0, v_texCoord)[0];
            float u = texture2D(tex1, v_texCoord)[1];
            float v = texture2D(tex1, v_texCoord)[3];

            gl_FragColor = yuv2rgb(y, u, v);
        }
    `,
};
formats['I420'] = {
    'mapping': (gl, frame) => {
        let width = frame.info.width;
        let height = frame.info.height;
        let stride = frame.info.stride;
        let offset0 = 0;
        let size0 = stride * height;
        let offset1 = offset0 + size0;
        let size1 = size0 / 4;
        let offset2 = offset1 + size1;
        let size2 = size0 / 4;
        return [{
                'data': new Uint8Array(frame.data, offset0, size0),
                'width': width,
                'height': height,
                'stride': stride,
                'format': gl.LUMINANCE,
            }, {
                'data': new Uint8Array(frame.data, offset1, size1),
                'width': width / 2,
                'height': height / 2,
                'stride': stride / 2,
                'format': gl.LUMINANCE,
            }, {
                'data': new Uint8Array(frame.data, offset2, size2),
                'width': width / 2,
                'height': height / 2,
                'stride': stride / 2,
                'format': gl.LUMINANCE,
            }];
    },
    'shader': `
        uniform sampler2D tex0;
        uniform sampler2D tex1;
        uniform sampler2D tex2;

        void main()
        {
            float y = texture2D(tex0, v_texCoord)[0];
            float u = texture2D(tex1, v_texCoord)[0];
            float v = texture2D(tex2, v_texCoord)[0];

            gl_FragColor = yuv2rgb(y, u, v);
        }
    `,
};
formats['YV12'] = {
    'mapping': formats['I420'].mapping,
    'shader': `
        uniform sampler2D tex0;
        uniform sampler2D tex1;
        uniform sampler2D tex2;

        void main()
        {
            float y = texture2D(tex0, v_texCoord)[0];
            float u = texture2D(tex2, v_texCoord)[0];
            float v = texture2D(tex1, v_texCoord)[0];

            gl_FragColor = yuv2rgb(y, u, v);
        }
    `,
};
formats['NV12'] = {
    'mapping': (gl, frame) => {
        let width = frame.info.width;
        let height = frame.info.height;
        let stride = frame.info.stride;
        let offset0 = 0;
        let size0 = stride * height;
        let offset1 = offset0 + size0;
        let size1 = size0 / 2;
        return [{
                'data': new Uint8Array(frame.data, offset0, size0),
                'width': width,
                'height': height,
                'stride': stride,
                'format': gl.LUMINANCE,
            }, {
                'data': new Uint8Array(frame.data, offset1, size1),
                'width': width / 2,
                'height': height / 2,
                'stride': stride,
                'format': gl.LUMINANCE_ALPHA,
            }];
    },
    'shader': `
        uniform sampler2D tex0;
        uniform sampler2D tex1;

        void main()
        {
            float y = texture2D(tex0, v_texCoord)[0];
            float u = texture2D(tex1, v_texCoord)[0];
            float v = texture2D(tex1, v_texCoord)[%alpha%];

            gl_FragColor = yuv2rgb(y, u, v);
        }
    `,
};
formats['NV21'] = {
    'mapping': formats['NV12'].mapping,
    'shader': `
        uniform sampler2D tex0;
        uniform sampler2D tex1;

        void main()
        {
            float y = texture2D(tex0, v_texCoord)[0];
            float u = texture2D(tex1, v_texCoord)[%alpha%];
            float v = texture2D(tex1, v_texCoord)[0];

            gl_FragColor = yuv2rgb(y, u, v);
        }
    `,
};
formats['IMC4'] = {
    'mapping': (gl, frame) => {
        let width = frame.info.width;
        let height = frame.info.height;
        let stride = frame.info.stride;
        let offset0 = 0;
        let size0 = stride * height;
        let offset1 = offset0 + size0;
        let size1 = size0 / 2;
        return [{
                'data': new Uint8Array(frame.data, offset0, size0),
                'width': width,
                'height': height,
                'stride': stride,
                'format': gl.LUMINANCE,
            }, {
                'data': new Uint8Array(frame.data, offset1, size1),
                'width': width,
                'height': height / 2,
                'stride': stride,
                'format': gl.LUMINANCE,
            }];
    },
    'shader': `
        uniform sampler2D tex0;
        uniform sampler2D tex1;

        void main()
        {
            float y = texture2D(tex0, v_texCoord)[0];
            float u = texture2D(tex1, vec2(v_texCoord.x * 0.5,       v_texCoord.y))[0];
            float v = texture2D(tex1, vec2(v_texCoord.x * 0.5 + 0.5, v_texCoord.y))[0];

            gl_FragColor = yuv2rgb(y, u, v);
        }
    `,
};
// -----------------------------------------------------------------------------
class GlResource {
    constructor(gl, handle) {
        this._context = gl;
        this._handle = handle;
    }
    get gl() {
        return this._context;
    }
    get handle() {
        return this._handle;
    }
    dispose() {
        delete this._context;
        delete this._handle;
    }
}
// -----------------------------------------------------------------------------
class GlTexture extends GlResource {
    constructor(gl) {
        let texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        super(gl, texture);
        this._width = null;
        this._height = null;
        this._format = null;
    }
    static alignStride(stride) {
        // tslint:disable-next-line:no-bitwise
        return GlTexture._textureUnpackAlignmentMap[stride & 7];
    }
    bind(unit) {
        this.gl.activeTexture(this.gl.TEXTURE0 + (unit || 0));
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.handle);
    }
    update(width, height, format, data) {
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.handle);
        let internalFormat = this._getInternalFormat(format);
        if (this._width !== width || this._height !== height || this._format !== format) {
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, internalFormat, width, height, 0, format, this.gl.UNSIGNED_BYTE, data);
        }
        else {
            this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, 0, 0, width, height, format, this.gl.UNSIGNED_BYTE, data);
        }
        this._width = width;
        this._height = height;
        this._format = format;
    }
    dispose() {
        if (this.handle) {
            this.gl.deleteTexture(this.handle);
        }
        super.dispose();
        delete this._width;
        delete this._height;
        delete this._format;
    }
    _getInternalFormat(format) {
        switch (format) {
            case this.gl.RED:
                return this.gl.R8;
            case this.gl.RG:
                return this.gl.RG8;
            default:
                return format;
        }
    }
}
GlTexture._textureUnpackAlignmentMap = [8, 1, 2, 1, 4, 1, 2, 1];
// -----------------------------------------------------------------------------
class GlArrayBuffer extends GlResource {
    constructor(gl) {
        super(gl, gl.createBuffer());
        this._data = null;
    }
    bind() {
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.handle);
    }
    update(data) {
        if (isArrayBufferViewEqual(data, this._data)) {
            return;
        }
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.handle);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, data, this.gl.STATIC_DRAW);
        this._data = data;
    }
    dispose() {
        if (this.handle) {
            this.gl.deleteBuffer(this.handle);
        }
        super.dispose();
    }
}
// -----------------------------------------------------------------------------
class GlShader extends GlResource {
    constructor(gl, shaderType, shaderSource) {
        let shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost()) {
            let lastError = gl.getShaderInfoLog(shader);
            gl.deleteShader(shader);
            throw new Error(`Shader compilation failed: ${lastError}`);
        }
        super(gl, shader);
    }
    dispose() {
        if (this.handle) {
            this.gl.deleteShader(this.handle);
        }
        super.dispose();
    }
}
// -----------------------------------------------------------------------------
class GlProgram extends GlResource {
    constructor(gl, vertexShader, fragmentShader) {
        let program = gl.createProgram();
        gl.attachShader(program, vertexShader.handle);
        gl.attachShader(program, fragmentShader.handle);
        gl.linkProgram(program);
        gl.detachShader(program, vertexShader.handle);
        gl.detachShader(program, fragmentShader.handle);
        vertexShader.dispose();
        fragmentShader.dispose();
        if (!gl.getProgramParameter(program, gl.LINK_STATUS) && !gl.isContextLost()) {
            let lastError = gl.getProgramInfoLog(program);
            gl.deleteProgram(program);
            throw new Error(`Program linking failed: ${lastError}`);
        }
        super(gl, program);
    }
    getAttribLocation(name) {
        return this.gl.getAttribLocation(this.handle, name);
    }
    getUniformLocation(name) {
        return this.gl.getUniformLocation(this.handle, name);
    }
    dispose() {
        if (this.handle) {
            this.gl.deleteProgram(this.handle);
        }
        super.dispose();
    }
}
// -----------------------------------------------------------------------------
function safeDispose(obj) {
    if (obj) {
        obj.dispose();
    }
}
function safeRemoveChild(element) {
    if (element) {
        element.remove();
    }
}
function safeInstanceOf(instance, constructor) {
    return !!(constructor && instance instanceof constructor);
}
function isArrayBufferViewEqual(buf1, buf2) {
    if (buf1 === buf2)
        return true;
    if (!buf1 || !buf2)
        return false;
    let array1 = new Int8Array(buf1.buffer, buf1.byteOffset, buf1.byteLength);
    let array2 = new Int8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
    if (array1.length !== array2.length)
        return false;
    for (let i = 0; i !== array1.length; i++) {
        if (array1[i] !== array2[i])
            return false;
    }
    return true;
}
function generateUniqueID() {
    return Math.random().toString(16).slice(2);
}
function generateCookie() {
    return generateUniqueID() + '@' + Date.now();
}
function invokeMethod(embed, method, args) {
    return new Promise((resolve, reject) => {
        if (!embed.postMessage) {
            throw new Error('Pepper plugin not loaded');
        }
        let cookie = generateCookie();
        let timeout = 1000;
        let timerID = null;
        let handler = (event) => {
            let msg = event.data;
            if (msg.cookie === cookie) {
                clearTimeout(timerID);
                embed.removeEventListener('message', handler);
                if (!('error' in msg)) {
                    resolve(msg.result);
                }
                else {
                    reject(msg.error);
                }
            }
        };
        let timeoutHandler = () => {
            embed.removeEventListener('message', handler);
            reject(new Error('Invoke Timeout'));
        };
        timerID = setTimeout(timeoutHandler, timeout);
        embed.addEventListener('message', handler);
        let message = {
            'cookie': cookie,
            'method': method,
            'args': args || {},
        };
        embed.postMessage(message);
    });
}
// -----------------------------------------------------------------------------
class Point {
    static swap(p1, p2) {
        let x = p2.x;
        let y = p2.y;
        p2.x = p1.x;
        p2.y = p1.y;
        p1.x = x;
        p1.y = y;
    }
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    transpose() {
        let tmp = this.x;
        this.x = this.y;
        this.y = tmp;
    }
    translate(offset) {
        this.x += offset.x;
        this.y += offset.y;
    }
}
// -----------------------------------------------------------------------------
class Rectangle {
    static uniform() {
        return new Rectangle(new Point(-1.0, -1.0), new Point(+1.0, +1.0));
    }
    constructor(p1, p2) {
        this.p1 = p1;
        this.p2 = p2;
    }
    applyScalingMode(mode, inputRatio, outputRatio) {
        for (let point of [this.p1, this.p2]) {
            if (mode === 2 /* Fit */) {
                if (inputRatio > outputRatio) {
                    point.y = point.y / inputRatio * outputRatio;
                }
                else {
                    point.x = point.x * inputRatio / outputRatio;
                }
            }
            else if (mode === 1 /* Crop */) {
                if (inputRatio < outputRatio) {
                    point.y = point.y / inputRatio * outputRatio;
                }
                else {
                    point.x = point.x * inputRatio / outputRatio;
                }
            }
        }
    }
    applyCropOffset(offset, bounds) {
        let x = Math.max(Math.min(offset.x, bounds.p1.x - this.p1.x), bounds.p2.x - this.p2.x);
        let y = Math.max(Math.min(offset.y, bounds.p1.y - this.p1.y), bounds.p2.y - this.p2.y);
        let safeOffset = new Point(x, y);
        this.p1.translate(safeOffset);
        this.p2.translate(safeOffset);
    }
    getCenterPoint() {
        let x = (this.p1.x + this.p2.x) / 2;
        let y = (this.p1.y + this.p2.y) / 2;
        return new Point(x, y);
    }
    toVertices() {
        return new Vertices([
            new Point(this.p1.x, this.p1.y),
            new Point(this.p1.x, this.p2.y),
            new Point(this.p2.x, this.p2.y),
            new Point(this.p2.x, this.p1.y),
        ]);
    }
}
// -----------------------------------------------------------------------------
class Vertices {
    constructor(vertices) {
        this._vertices = vertices;
    }
    mirror() {
        Point.swap(this._vertices[1], this._vertices[2]);
        Point.swap(this._vertices[0], this._vertices[3]);
    }
    getTriangleData() {
        let data = [];
        let indexes = [0, 1, 2, 2, 3, 0];
        for (let i of indexes) {
            data.push(this._vertices[i].x, this._vertices[i].y);
        }
        return new Float32Array(data);
    }
}
// -----------------------------------------------------------------------------
class NoopLogger {
    createChild() { return this; }
    log() { }
    debug() { }
    info() { }
    warn() { }
    error() { }
}
// -----------------------------------------------------------------------------
class VideoRendererBase extends events_1.EventEmitter {
    constructor(_frameSink, _logger) {
        super();
        this._frameSink = _frameSink;
        this._logger = _logger;
        this._videoWidth = 0;
        this._videoHeight = 0;
        this._cleanupHandlers = [];
        this._pendingTimeout = null;
    }
    static getUniqueId() {
        return ++VideoRendererBase._counter;
    }
    getFrameSink() {
        return this._frameSink;
    }
    getVideoSize() {
        return {
            width: this._videoWidth,
            height: this._videoHeight,
        };
    }
    _addEventListener(element, type, listener) {
        element.addEventListener(type, listener);
        this._cleanupHandlers.push(() => element.removeEventListener(type, listener));
    }
    _setVideoPreference(width, height) {
        if (this._pendingTimeout) {
            clearTimeout(this._pendingTimeout);
        }
        let handler = () => {
            this._pendingTimeout = null;
            this._logger.debug(`setVideoPreference: ${width} x ${height}`);
            this._frameSink.setVideoPreference(width, height);
        };
        this._pendingTimeout = setTimeout(handler, SET_VIDEO_PREFERENCE_DEBOUNCE_TIMEOUT);
    }
    _updateVideoSize(videoWidth, videoHeight) {
        if (this._videoWidth !== videoWidth || this._videoHeight !== videoHeight) {
            this._videoWidth = videoWidth;
            this._videoHeight = videoHeight;
            this._logger.debug(`video-size-changed: ${videoWidth} x ${videoHeight}`);
            this.emit('video-size-changed', {
                'width': videoWidth,
                'height': videoHeight,
            });
        }
    }
    dispose() {
        if (this._cleanupHandlers) {
            this._cleanupHandlers.forEach((handler) => handler());
        }
        if (this._pendingTimeout) {
            clearTimeout(this._pendingTimeout);
        }
        safeDispose(this._frameSink);
        delete this._videoWidth;
        delete this._videoHeight;
        delete this._cleanupHandlers;
        delete this._frameSink;
        delete this._pendingTimeout;
    }
}
VideoRendererBase._counter = 0;
class CanvasVideoRenderer extends VideoRendererBase {
    constructor(args, frameSink) {
        super(frameSink, (args.logger || new NoopLogger()).createChild(`CanvasVideoRenderer #${VideoRendererBase.getUniqueId()}`));
        this._context = null;
        this._contextIsWebGL2 = false;
        this._scalingMode = 0 /* Stretch */;
        this._program = null;
        this._verticesBuffer = null;
        this._texCoordBuffer = null;
        this._textures = [];
        this._textureLocations = [];
        this._mirror = false;
        this._format = null;
        this._timer = null;
        this._cropInfo = null;
        this._alignment = null;
        this._logger.debug('constructor');
        this._scalingMode = args.scalingMode;
        this._initialize(args);
    }
    getRendererType() {
        return this._contextIsWebGL2 ? 2 /* WebGLv2 */ : 1 /* WebGLv1 */;
    }
    setScalingMode(mode) {
        this._logger.debug(`setScalingMode: ${mode}`);
        this._scalingMode = mode;
        this._render();
        return Promise.resolve();
    }
    dispose() {
        this._logger.debug('dispose');
        if (this._timer) {
            cancelAnimationFrame(this._timer);
        }
        safeDispose(this._program);
        safeDispose(this._verticesBuffer);
        safeDispose(this._texCoordBuffer);
        if (this._textures) {
            this._textures.forEach((texture) => texture.dispose());
        }
        if (this._context) {
            safeRemoveChild(this._context.canvas);
        }
        delete this._frameSink;
        delete this._context;
        delete this._scalingMode;
        delete this._program;
        delete this._verticesBuffer;
        delete this._texCoordBuffer;
        delete this._textures;
        delete this._textureLocations;
        delete this._mirror;
        delete this._format;
        delete this._timer;
        delete this._cropInfo;
        delete this._alignment;
        super.dispose();
    }
    _createContext(canvas, args) {
        let attributes = {
            'alpha': args.transparent,
            'depth': false,
            'stencil': false,
            'antialias': false,
            'premultipliedAlpha': false,
            'preserveDrawingBuffer': false,
        };
        if (args.useLowPowerGPU) {
            attributes.powerPreference = 'low-power';
        }
        if (args.useWebGL2) {
            let context = canvas.getContext('webgl2', attributes);
            if (context)
                return context;
        }
        let context = canvas.getContext('webgl', attributes);
        if (!context) {
            this._logger.error('WebGL context init failed');
            throw new VideoRendererError('WebGL context init failed', 1 /* ContextFailed */);
        }
        return context;
    }
    _createProgram(format) {
        let gl = this._context;
        if (!format)
            return null;
        let formatInfo = formats[format];
        if (!formatInfo) {
            this._logger.warn(`Invalid format: ${format}`);
            return null;
        }
        let fragmentShaderSource = FRAGMENT_SHADER_COMMON
            + formatInfo.shader.replace('%alpha%', this._contextIsWebGL2 ? '1' : '3');
        let vertexShader = new GlShader(gl, gl.VERTEX_SHADER, VERTEX_SHADER);
        let fragmentShader = new GlShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        return new GlProgram(gl, vertexShader, fragmentShader);
    }
    _initProgram(format) {
        let gl = this._context;
        let program = this._createProgram(format);
        if (!program) {
            this._textureLocations = [];
            return null;
        }
        let positionLocation = program.getAttribLocation('position');
        this._getVerticesBuffer().bind();
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        let texCoordLocation = program.getAttribLocation('texCoord');
        this._getTexCoordBuffer().bind();
        gl.enableVertexAttribArray(texCoordLocation);
        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
        this._textureLocations = [
            program.getUniformLocation('tex0'),
            program.getUniformLocation('tex1'),
            program.getUniformLocation('tex2'),
        ];
        return program;
    }
    _mapTextureFormat(format) {
        let gl = this._context;
        switch (format) {
            case gl.LUMINANCE:
                return gl.RED;
            case gl.LUMINANCE_ALPHA:
                return gl.RG;
            default:
                return format;
        }
    }
    _mapFrameToTextures(frame) {
        if (!frame)
            return [];
        let formatInfo = formats[frame.info.format];
        if (!formatInfo)
            return [];
        let result = formatInfo.mapping(this._context, frame);
        if (!this._contextIsWebGL2)
            return result;
        for (let item of result) {
            item.format = this._mapTextureFormat(item.format);
        }
        return result;
    }
    _setUnpackAlignment(alignment) {
        let gl = this._context;
        if (this._alignment !== alignment) {
            gl.pixelStorei(gl.UNPACK_ALIGNMENT, alignment);
        }
        this._alignment = alignment;
    }
    _updateTextures(frame) {
        let input = this._mapFrameToTextures(frame);
        while (this._textures.length < input.length) {
            this._textures.push(new GlTexture(this._context));
        }
        input.forEach((item, i) => {
            this._setUnpackAlignment(GlTexture.alignStride(item.stride));
            this._textures[i].update(item.width, item.height, item.format, item.data);
        });
        while (this._textures.length > input.length) {
            this._textures.pop().dispose();
        }
    }
    _updateProgram(format) {
        let gl = this._context;
        if (format === this._format)
            return;
        if (this._program) {
            this._program.dispose();
        }
        let program = this._initProgram(format);
        this._program = program;
        this._format = format;
        gl.useProgram(program ? program.handle : null);
    }
    _getCropOffset(cropInfo) {
        let rect = Rectangle.uniform();
        let p1 = new Point(this._mirror ? cropInfo.rightOffset : cropInfo.leftOffset, cropInfo.bottomOffset);
        let p2 = new Point(this._mirror ? cropInfo.leftOffset : cropInfo.rightOffset, cropInfo.topOffset);
        rect.p1.x -= p1.x / this._videoWidth * 2;
        rect.p1.y -= p1.y / this._videoHeight * 2;
        rect.p2.x += p2.x / this._videoWidth * 2;
        rect.p2.y += p2.y / this._videoHeight * 2;
        rect.applyScalingMode(this._scalingMode, this._getInputRatio(), this._getOutputRatio());
        return rect.getCenterPoint();
    }
    _updateVertices() {
        let rect = Rectangle.uniform();
        rect.applyScalingMode(this._scalingMode, this._getInputRatio(), this._getOutputRatio());
        if (this._cropInfo && this._scalingMode === 1 /* Crop */) {
            let offset = this._getCropOffset(this._cropInfo);
            let bounds = Rectangle.uniform();
            rect.applyCropOffset(offset, bounds);
        }
        let vertices = rect.toVertices();
        if (this._mirror) {
            vertices.mirror();
        }
        this._getVerticesBuffer().update(vertices.getTriangleData());
    }
    _updateTextureCoords() {
        let texels = new Vertices([
            new Point(0.0, 1.0),
            new Point(0.0, 0.0),
            new Point(1.0, 0.0),
            new Point(1.0, 1.0),
        ]);
        this._getTexCoordBuffer().update(texels.getTriangleData());
    }
    _getVerticesBuffer() {
        if (!this._verticesBuffer) {
            this._verticesBuffer = new GlArrayBuffer(this._context);
        }
        return this._verticesBuffer;
    }
    _getTexCoordBuffer() {
        if (!this._texCoordBuffer) {
            this._texCoordBuffer = new GlArrayBuffer(this._context);
        }
        return this._texCoordBuffer;
    }
    _getInputRatio() {
        return this._videoWidth / this._videoHeight;
    }
    _getOutputRatio() {
        return this._context.drawingBufferWidth / this._context.drawingBufferHeight;
    }
    _render() {
        let gl = this._context;
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        if (!this._program || this._textures.length === 0)
            return;
        this._textures.forEach((texture, i) => {
            texture.bind(i);
            gl.uniform1i(this._textureLocations[i], i);
        });
        this._updateVertices();
        this._updateTextureCoords();
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
    _resize() {
        let gl = this._context;
        let scale = window.devicePixelRatio || 1;
        let displayWidth = Math.floor(gl.canvas.clientWidth * scale);
        let displayHeight = Math.floor(gl.canvas.clientHeight * scale);
        if (gl.canvas.width !== displayWidth || gl.canvas.height !== displayHeight) {
            gl.canvas.width = displayWidth;
            gl.canvas.height = displayHeight;
            this._setVideoPreference(gl.drawingBufferWidth, gl.drawingBufferHeight);
            return true;
        }
        return false;
    }
    _checkVideoSize(frame) {
        let videoWidth = frame ? frame.info.origWidth : 0;
        let videoHeight = frame ? frame.info.origHeight : 0;
        this._updateVideoSize(videoWidth, videoHeight);
    }
    _updateFrame(frame) {
        this._checkVideoSize(frame);
        this._updateTextures(frame);
        this._updateProgram(frame ? frame.info.format : null);
        this._cropInfo = frame ? frame.info.cropInfo : null;
        this._mirror = frame ? frame.info.mirror : false;
    }
    get _canvasFrameSink() {
        return this._frameSink;
    }
    _drawFrame() {
        if (!this._frameSink)
            return;
        let frame = this._canvasFrameSink.getFrame();
        let frameUpdated = frame !== undefined;
        if (frameUpdated) {
            this._updateFrame(frame);
        }
        if (this._resize() || frameUpdated) {
            this._render();
        }
        this._timer = requestAnimationFrame(this._drawFrame.bind(this));
    }
    _handleContextRestored() {
        this._logger.debug('requestAnimationFrame');
        this._timer = requestAnimationFrame(this._drawFrame.bind(this));
    }
    _handleContextLost() {
        this._logger.debug('cancelAnimationFrame');
        cancelAnimationFrame(this._timer);
        this._program = null;
        this._verticesBuffer = null;
        this._texCoordBuffer = null;
        this._textures = [];
        this._textureLocations = [];
        this._format = null;
        this._timer = null;
        this._alignment = null;
    }
    _initialize(args) {
        let document = args.container.ownerDocument;
        let canvas = document.createElement('canvas');
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        args.container.appendChild(canvas);
        this._addEventListener(canvas, 'webglcontextcreationerror', (event) => {
            this._logger.error(event.statusMessage);
        });
        this._context = this._createContext(canvas, args);
        this._contextIsWebGL2 = safeInstanceOf(this._context, window['WebGL2RenderingContext']);
        this._logger.info(`Using WebGL context version: ${this._contextIsWebGL2 ? '2' : '1'}`);
        this._addEventListener(this._context.canvas, 'webglcontextlost', (event) => {
            this._logger.warn('WebGLRenderingContext lost');
            event.preventDefault();
            this._handleContextLost();
        });
        this._addEventListener(this._context.canvas, 'webglcontextrestored', (event) => {
            this._logger.warn('WebGLRenderingContext restored');
            this._handleContextRestored();
        });
        this._handleContextRestored();
    }
}
exports.CanvasVideoRenderer = CanvasVideoRenderer;
class PepperVideoRenderer extends VideoRendererBase {
    constructor(args, frameSink) {
        super(frameSink, (args.logger || new NoopLogger()).createChild(`PepperVideoRenderer #${VideoRendererBase.getUniqueId()}`));
        this._embed = null;
        this._embedEvents = new events_1.EventEmitter();
        this._logger.debug('constructor');
        this._initialize(args);
    }
    dispose() {
        this._logger.debug(`dispose`);
        safeRemoveChild(this._embed);
        if (this._embedEvents) {
            this._embedEvents.removeAllListeners();
        }
        delete this._embed;
        delete this._embedEvents;
        super.dispose();
    }
    getRendererType() {
        return 3 /* Pepper */;
    }
    setScalingMode(mode) {
        this._logger.debug(`setScalingMode: ${mode}`);
        return invokeMethod(this._embed, 'setScalingMode', {
            'mode': this._getScalingMode(mode),
        })
            .catch((error) => {
            this._logger.error(`setScalingMode failed: ${error}`);
            throw error;
        });
    }
    get _pepperFrameSink() {
        return this._frameSink;
    }
    _initialize(args) {
        this._embed = this._createEmbed(args);
        args.container.appendChild(this._embed);
        this._addEventListener(this._embed, 'message', (event) => {
            let msg = event.data;
            if (msg.event) {
                this._embedEvents.emit(msg.event, msg.args);
            }
        });
        this._embedEvents.on('window-size-changed', (args) => {
            this._setVideoPreference(args.width, args.height);
        });
        this._embedEvents.on('video-size-changed', (args) => {
            this._updateVideoSize(args.width, args.height);
        });
    }
    _createEmbed(args) {
        let document = args.container.ownerDocument;
        let embed = document.createElement('embed');
        embed.setAttribute('type', version_1.videoRendererPlugin.mimeType);
        embed.setAttribute('scaling-mode', this._getScalingMode(args.scalingMode));
        embed.setAttribute('transparent', args.transparent ? 'true' : 'false');
        embed.setAttribute('buffer-name', this._pepperFrameSink.getBufferName());
        // embed.setAttribute('use-discreet-gpu', 'true');
        embed.style.width = '100%';
        embed.style.height = '100%';
        return embed;
    }
    _getScalingMode(mode) {
        switch (mode) {
            case 0 /* Stretch */:
                return 'stretch';
            case 1 /* Crop */:
                return 'crop';
            case 2 /* Fit */:
                return 'fit';
            default:
                return undefined;
        }
    }
}
exports.PepperVideoRenderer = PepperVideoRenderer;
class ChromiumVideoRenderer extends VideoRendererBase {
    constructor(args, frameSink) {
        super(frameSink, (args.logger || new NoopLogger()).createChild(`ChromiumVideoRenderer #${VideoRendererBase.getUniqueId()}`));
        this._videoElement = null;
        this._scalingMode = 0 /* Stretch */;
        this._rendererWidth = 0;
        this._rendererHeight = 0;
        this._videoPositionX = 0.5;
        this._videoPositionY = 0.5;
        this._logger.debug('constructor');
        this._scalingMode = args.scalingMode;
        this._initialize(args);
    }
    dispose() {
        this._logger.debug(`dispose`);
        safeRemoveChild(this._videoElement);
        delete this._videoElement;
        delete this._scalingMode;
        delete this._rendererWidth;
        delete this._rendererHeight;
        delete this._videoPositionX;
        delete this._videoPositionY;
        super.dispose();
    }
    getRendererType() {
        return 4 /* Chromium */;
    }
    setScalingMode(mode) {
        this._logger.debug(`setScalingMode: ${mode}`);
        this._setScalingMode(mode);
        return Promise.resolve();
    }
    get _pepperFrameSink() {
        return this._frameSink;
    }
    _initialize(args) {
        this._videoElement = this._createVideoElement(args);
        args.container.appendChild(this._videoElement);
        this._addEventListener(this._videoElement, 'error', (event) => this._logError(event));
        this._addEventListener(this._videoElement, 'resize', () => this._checkVideoSize());
        this._addEventListener(this._videoElement, 'msRendererSizeChanged', () => this._checkRendererSize());
        this._addEventListener(this._videoElement, 'msVideoPositionChanged', () => this._checkVideoPosition());
        this._logMediaEvents();
    }
    _createVideoElement(args) {
        let document = args.container.ownerDocument;
        let video = document.createElement('video');
        video.src = 'skypevideo:' + this._pepperFrameSink.getBufferName();
        video.style.backgroundColor = args.transparent ? '' : 'black';
        video.style.width = '100%';
        video.style.height = '100%';
        video.style.objectFit = this._getObjectFit();
        video.style.objectPosition = this._getObjectPosition();
        return video;
    }
    _logError(event) {
        if (event instanceof ErrorEvent) {
            this._logger.error(`error: ${event.message}`);
        }
        else {
            this._logger.error(`error: ${formatMediaError(this._videoElement.error)}`);
        }
    }
    _logMediaEvents() {
        let eventNames = [
            'playing',
            'waiting',
            'seeking',
            'seeked',
            'ended',
            'loadedmetadata',
            'loadeddata',
            'canplay',
            'canplaythrough',
            'duration',
            'timeupdate',
            'play',
            'pause',
            'ratechange',
            'volumechange',
            'suspend',
            'emptied',
            'stalled',
        ];
        let logEvent = (eventName) => {
            let readyState = formatReadyState(this._videoElement.readyState);
            let networkState = formatNetworkState(this._videoElement.networkState);
            this._logger.debug(`${eventName}, readyState: ${readyState}, networkState: ${networkState}`);
        };
        for (let eventName of eventNames) {
            this._addEventListener(this._videoElement, eventName, () => logEvent(eventName));
        }
    }
    _checkVideoSize() {
        let videoWidth = this._videoElement.videoWidth;
        let videoHeight = this._videoElement.videoHeight;
        this._updateVideoSize(videoWidth, videoHeight);
    }
    _checkRendererSize() {
        let scale = window.devicePixelRatio || 1;
        let rendererWidth = Math.floor(this._videoElement.msRendererWidth * scale) || 0;
        let rendererHeight = Math.floor(this._videoElement.msRendererHeight * scale) || 0;
        if (this._rendererWidth !== rendererWidth || this._rendererHeight !== rendererHeight) {
            this._rendererWidth = rendererWidth;
            this._rendererHeight = rendererHeight;
            this._setVideoPreference(rendererWidth, rendererHeight);
        }
    }
    _checkVideoPosition() {
        this._videoPositionX = this._videoElement.msVideoPositionX;
        this._videoPositionY = this._videoElement.msVideoPositionY;
        this._videoElement.style.objectPosition = this._getObjectPosition();
    }
    _setScalingMode(mode) {
        this._scalingMode = mode;
        this._videoElement.style.objectFit = this._getObjectFit();
        this._videoElement.style.objectPosition = this._getObjectPosition();
    }
    _getObjectFit() {
        switch (this._scalingMode) {
            case 0 /* Stretch */:
                return 'fill';
            case 1 /* Crop */:
                return 'cover';
            case 2 /* Fit */:
                return 'contain';
            default:
                return undefined;
        }
    }
    _getObjectPosition() {
        if (this._scalingMode === 1 /* Crop */) {
            let xPosition = Number.isFinite(this._videoPositionX) ? this._videoPositionX : 0.5;
            let yPosition = Number.isFinite(this._videoPositionY) ? this._videoPositionY : 0.5;
            return `${Math.round(xPosition * 100)}% ${Math.round(yPosition * 100)}%`;
        }
        return '';
    }
}
exports.ChromiumVideoRenderer = ChromiumVideoRenderer;
function formatMediaError(error) {
    if (!error) {
        return undefined;
    }
    switch (error.code) {
        case MediaError.MEDIA_ERR_ABORTED:
            return 'MEDIA_ERR_ABORTED';
        case MediaError.MEDIA_ERR_NETWORK:
            return 'MEDIA_ERR_NETWORK';
        case MediaError.MEDIA_ERR_DECODE:
            return 'MEDIA_ERR_DECODE';
        case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
            return 'MEDIA_ERR_SRC_NOT_SUPPORTED';
        default:
            return undefined;
    }
}
function formatReadyState(value) {
    switch (value) {
        case HTMLMediaElement.HAVE_NOTHING:
            return 'HAVE_NOTHING';
        case HTMLMediaElement.HAVE_METADATA:
            return 'HAVE_METADATA';
        case HTMLMediaElement.HAVE_CURRENT_DATA:
            return 'HAVE_CURRENT_DATA';
        case HTMLMediaElement.HAVE_FUTURE_DATA:
            return 'HAVE_FUTURE_DATA';
        case HTMLMediaElement.HAVE_ENOUGH_DATA:
            return 'HAVE_ENOUGH_DATA';
        default:
            return undefined;
    }
}
function formatNetworkState(value) {
    switch (value) {
        case HTMLMediaElement.NETWORK_EMPTY:
            return 'NETWORK_EMPTY';
        case HTMLMediaElement.NETWORK_IDLE:
            return 'NETWORK_IDLE';
        case HTMLMediaElement.NETWORK_LOADING:
            return 'NETWORK_LOADING';
        case HTMLMediaElement.NETWORK_NO_SOURCE:
            return 'NETWORK_NO_SOURCE';
        default:
            return undefined;
    }
}
class ControlCapturer extends events_1.EventEmitter {
    constructor(args) {
        super();
        this._embed = null;
        this._embedEvents = new events_1.EventEmitter();
        this._cleanupHandlers = [];
        this._logger = (args.logger || new NoopLogger()).createChild('ControlCapturer');
        this._logger.debug('constructor');
        this._initialize(args);
    }
    dispose() {
        this._logger.debug('dispose');
        safeRemoveChild(this._embed);
        if (this._embedEvents) {
            this._embedEvents.removeAllListeners();
        }
        if (this._cleanupHandlers) {
            this._cleanupHandlers.forEach((handler) => handler());
        }
        delete this._embed;
        delete this._embedEvents;
        delete this._logger;
        delete this._cleanupHandlers;
    }
    setCaptureMode(mode) {
        this._logger.debug(`setCaptureMode: ${mode}`);
        return invokeMethod(this._embed, 'setCaptureMode', {
            'mode': this._getCaptureMode(mode),
        })
            .catch((error) => {
            this._logger.error(`setCaptureMode failed: ${error}`);
            throw error;
        });
    }
    _initialize(args) {
        this._embed = this._createEmbed(args.container);
        args.container.appendChild(this._embed);
        this._addEventListener(this._embed, 'message', (event) => {
            let msg = event.data;
            if (msg.event) {
                this._embedEvents.emit(msg.event, msg.args);
            }
        });
        this._embedEvents.on('ready', () => {
            this._logger.debug('ready');
            this._setVideoSize(args.renderer.getVideoSize());
        });
        this._embedEvents.on('control-event', (args) => {
            this.emit('control-event', {
                'data': new Buffer(args.data),
            });
        });
        this._embedEvents.on('did-change-focus', (args) => {
            this.emit('did-change-focus', args);
        });
        this._embedEvents.on('capture-event', (args) => {
            this.emit('capture-event', args);
        });
        let videoSizeChanged = (args) => {
            this._setVideoSize(args);
        };
        args.renderer.on('video-size-changed', videoSizeChanged);
        this._cleanupHandlers.push(() => {
            args.renderer.removeListener('video-size-changed', videoSizeChanged);
        });
    }
    _createEmbed(container) {
        let document = container.ownerDocument;
        let embed = document.createElement('embed');
        embed.setAttribute('type', version_1.controlCapturerPlugin.mimeType);
        embed.style.width = '100%';
        embed.style.height = '100%';
        return embed;
    }
    _addEventListener(element, type, listener) {
        element.addEventListener(type, listener);
        this._cleanupHandlers.push(() => element.removeEventListener(type, listener));
    }
    _setVideoSize(size) {
        invokeMethod(this._embed, 'setVideoSize', size);
    }
    _getCaptureMode(mode) {
        switch (mode) {
            case 0 /* Disabled */:
                return 'disabled';
            case 1 /* Detection */:
                return 'detection';
            case 2 /* Pointer */:
                return 'pointer';
            case 3 /* Control */:
                return 'control';
            default:
                return undefined;
        }
    }
}
exports.ControlCapturer = ControlCapturer;
// -----------------------------------------------------------------------------
class VideoRendererError extends Error {
    constructor(message, reason = 0 /* Unknown */) {
        super(message);
        this.reason = reason;
    }
}
exports.VideoRendererError = VideoRendererError;
function createCanvasVideoRenderer(frameSink, args) {
    return new CanvasVideoRenderer(args, frameSink);
}
exports.createCanvasVideoRenderer = createCanvasVideoRenderer;
function createPepperVideoRenderer(frameSink, args) {
    return new PepperVideoRenderer(args, frameSink);
}
exports.createPepperVideoRenderer = createPepperVideoRenderer;
function createChromiumVideoRenderer(frameSink, args) {
    return new ChromiumVideoRenderer(args, frameSink);
}
exports.createChromiumVideoRenderer = createChromiumVideoRenderer;
function createControlCapturer(args) {
    return new ControlCapturer(args);
}
exports.createControlCapturer = createControlCapturer;
function isPluginAvailable(mimeType) {
    let entry = navigator.mimeTypes[mimeType];
    return !!(entry && entry.enabledPlugin);
}
function isControlCapturerAvailable() {
    return isPluginAvailable(version_1.controlCapturerPlugin.mimeType);
}
exports.isControlCapturerAvailable = isControlCapturerAvailable;
function isPepperVideoRendererAvailable() {
    return isPluginAvailable(version_1.videoRendererPlugin.mimeType);
}
exports.isPepperVideoRendererAvailable = isPepperVideoRendererAvailable;
function isChromiumVideoRendererAvailable() {
    let video = document.createElement('video');
    return video.canPlayType('application/x-skype-video') === 'probably';
}
exports.isChromiumVideoRendererAvailable = isChromiumVideoRendererAvailable;
//# sourceMappingURL=video-renderer.js.map